import numpy as np
import exoplanet as xo
import starry

def validate_params(kwargs, param_names):
    if len(kwargs) > len(param_names):
        raise ValueError(
            "Too many arguments given. Expected 1 argument.")
    for p in param_names:
        if not p in kwargs:
            raise ValueError("Missing required parameter {0}.".format(p))

class Mean:
    """The abstract base class that is the superclass of 
    all other means
    """
    
    def __init__(self, nw=1, **kwargs):
        self.nw = nw
        for k, v in kwargs.items():
            setattr(self, k, v)
    
    def __add__(self, m):
        return MeanSum(self, m)
    
    def __radd__(self, m):
        return MeanSum(m, self)
    
    def __mul__(self, m):
        return MeanProd(self, m)
    
    def __rmul__(self, m):
        return MeanProd(m, self)
    
    def evaluate(self, x):
        return np.zeros(len(x), self.nw)
    
class ConstantMean(Mean):
    """A constant mean
    
    Args:
        Float C: The constant value of the mean or an 
            array of values, one for each wavelength.
    """
    
    param_names = ("C")
    
    def __init__(self, nw=1, **kwargs):
        
        validate_params(kwargs, self.param_names)
        super(ConstantMean, self).__init__(nw, **kwargs)
        
        try:
            self.C = np.full(nw, self.C)
        except ValueError:
            print("Length of C does not match number of wavelengths, nw. "
                  "C should be either a float or an array of length nw.")
        
    def evaluate(self, x):
        return self.C[:, None] * np.ones_like(x)
    
class LinearMean(Mean):
    
    """A mean function that increases linearly from A to B
    
    Args:
        Float A: The initial value of the linear ramp or an 
            array of values, one for each wavelength
        Float B: The final value of the linear ramp or an 
            array of values, one for each wavelength
    """
    
    param_names = ("A", "B")
    
    def __init__(self, nw=1, **kwargs):
        validate_params(kwargs, self.param_names)
        super(LinearMean, self).__init__(nw, **kwargs)
        
        try:
            self.A = np.full(nw, self.A)
            self.B = np.full(nw, self.B)
        except ValueError:
            print("Length of A or B does not match number of wavelengths, nw. "
                  "A and B should be either floats or arrays of length nw.")
        
    def evaluate(self, x):
        rise = self.B - self.A
        run = x.max() - x.min()
        slope = rise / run
        return self.A[:, None] + (x - x.min())*slope[:, None]
    
class StarryPhaseCurve(Mean):
    
    """The phase curve of a starry model. 
    A phase curve is generated by integrating the flux of a starry 
    map over the spherical body as it rotates. 
    
    Args:
        int lmax: the number of spherical harmonic orders
        tensor Y: the spherical harmonic coefficients
        float Prot: the rotation period of the body
    """
    
    param_names = ("lmax", "Y", "Prot")
    
    def __init__(self, nw=1, **kwargs):
        validate_params(kwargs, self.param_names)
        super(StarryPhaseCurve, self).__init__(nw, **kwargs)
        
        self.starrymap = starry.Map(lmax=self.lmax, nwav=nw)
        try:
            for l in range(self.lmax):
                for m in range(2*l+1):
                    self.starrymap[l, m-l] = np.full(nw, self.Y[l][m])
        except ValueError:
            print("Length of an entry in Y does not match the number of wavlengths, nw."
                 "All entries in Y should be either floats or arrays of length nw.")
        except IndexError:
            print("Invalid number of spherical harmonic coefficients.")
            
    def evaluate(self, x):
        theta = ((x % self.Prot) / self.Prot) * 360
        return self.starrymap.flux(theta=theta)
    
class StarryOccultationCurve(Mean):
    
    """The occultation light curve of a starry model. 
    A occultation light curve is generated by computing the 
    flux from a starry map as it is occulted by a body of radius r0. 
    
    Args:
        int lmax: the number of spherical harmonic orders
        tensor Y: the spherical harmonic coefficients
        float delta: the duration of the occultation
        float b0: the impact parameter of the occulting body
        float t0: the time at the center of the occultation
        float r0: the radius of the occulting body in units of the radius of the occulted body
    """
    
    param_names = ("lmax", "Y", "delta", "b0", "t0", "r0")
    
    def __init__(self, nw=1, **kwargs):
        validate_params(kwargs, self.param_names)
        super(StarryOccultationCurve, self).__init__(nw, **kwargs)
        
        self.starrymap = starry.Map(lmax=self.lmax, nwav=nw)
        try:
            for l in range(self.lmax):
                for m in range(2*l+1):
                    self.starrymap[l, m-l] = np.full(nw, self.Y[l][m])
        except ValueError:
            print("Length of an entry in Y does not match the number of wavlengths, nw."
                 "All entries in Y should be either floats or arrays of length nw.")
        except IndexError:
            print("Invalid number of spherical harmonic coefficients.")
            
    def evaluate(self, x):
        
        xstart = (x.max() - x.min()) / self.delta
        x0 = np.linspace(-xstart, xstart, len(x))
        return self.starrymap.flux(xo=x0, yo=self.b0, ro=self.r0)
    
class StarryLDCurve(Mean):
    
    """The occultation light curve of a starry model 
    with quadratic limb-darkening only. 
    
    Args:
        array u: the quadratic limb-darkening parameters
        float delta: the duration of the occultation
        float b0: the impact parameter of the occulting body
        float t0: the time at the center of the occultation
        float r0: the radius of the occulting body in units of the radius of the occulted body
    """
    
    param_names = ("u", "delta", "b0", "t0", "r0")
    
    def __init__(self, nw=1, **kwargs):
        validate_params(kwargs, self.param_names)
        super(StarryLDCurve, self).__init__(nw, **kwargs)
        
        self.starrymap = starry.Map(nwav=nw)
        
        try:
            self.starrymap[1] = np.full(nw, self.u[0])
            self.starrymap[2] = np.full(nw, self.u[1])
        except ValueError:
            print("Length of an entry in u does not match the number of wavlengths, nw."
                 "All entries in u should be either floats or arrays of length nw.")
        
    def evaluate(self, x):
        xstart = (x.max() - x.min()) / self.delta
        x0 = np.linspace(-xstart, xstart, len(x))
        return self.starrymap.flux(xo=x0, yo=self.b0, ro=self.r0)