import numpy as np
import starry
import theano.tensor as tt

def validate_params(kwargs, param_names):
    if len(kwargs) > len(param_names):
        raise ValueError(
            "Too many arguments given. Expected 1 argument.")
    for p in param_names:
        if not p in kwargs:
            raise ValueError("Missing required parameter {0}.".format(p))

class Mean:
    """The abstract base class that is the superclass of 
    all other means
    """
    
    def __init__(self, nw=1, **kwargs):
        self.nw = nw
        for k, v in kwargs.items():
            setattr(self, k, v)
            
        self.param_names = self.get_param_names()
    
    def __add__(self, m):
        if self.nw == m.nw:
            return MeanSum(self, m)
        else:
            raise ValueError("Each mean must have the same number of wavelengths.")
    
    def __radd__(self, m):
        if self.nw == m.nw:
            return MeanSum(m, self)
        else:
            raise ValueError("Each mean must have the same number of wavelengths.")
            
    def get_param_names(self):
        return []
    
    def evaluate(self, x):
        return tt.zeros((len(x), self.nw))
    
class MeanSum(Mean):
    
    def __init__(self, *means, **kwargs):
        self.means = means
        super(MeanSum, self).__init__(means[0].nw, **kwargs)
        
    def __add__(self, m):
        if self.nw == m.nw:
            return MeanSum(*self.means, m)
        else:
            raise ValueError("Each mean must have the same number of wavelengths.")
    
    def __radd__(self, m):
        if self.nw == m.nw:
            return MeanSum(m, *self.means)
        else:
            raise ValueError("Each mean must have the same number of wavelengths.")
            
    def get_param_names(self):
        param_names = []
        for m in self.means:
            param_names.extend(m.get_param_names())
        return param_names
    
    def evaluate(self, x):
        return tt.sum([m.evaluate(x) for m in self.means], axis=0)
    
class ConstantMean(Mean):
    """A constant mean
    
    Args:
        Float C: The constant value of the mean or an 
            array of values, one for each wavelength.
    """
        
    def __init__(self, nw=1, **kwargs):
        
        validate_params(kwargs, self.get_param_names())
        super(ConstantMean, self).__init__(nw, **kwargs)
        
        try:
            self.C = np.full(nw, self.C)
        except ValueError:
            print("Length of C does not match number of wavelengths, nw. "
                  "C should be either a float or an array of length nw.")
            
    def get_param_names(self):
        return ["C"]
        
    def evaluate(self, x):
        return (self.C[:, None] * tt.ones_like(x)).T
    
class LinearMean(Mean):
    
    """A mean function that increases linearly from A to B
    
    Args:
        Float A: The initial value of the linear ramp or an 
            array of values, one for each wavelength
        Float B: The final value of the linear ramp or an 
            array of values, one for each wavelength
    """
        
    def __init__(self, nw=1, **kwargs):
        validate_params(kwargs, self.get_param_names())
        super(LinearMean, self).__init__(nw, **kwargs)
        
        try:
            self.A = tt.ones(nw).fill(self.A)
            self.B = tt.ones(nw).fill(self.B)
        except ValueError:
            print("Length of A or B does not match number of wavelengths, nw. "
                  "A and B should be either floats or arrays of length nw.")
            
    def get_param_names(self):
        return ["A", "B"]
        
    def evaluate(self, x):
        rise = self.B - self.A
        run = x.max() - x.min()
        slope = rise / run
        return (self.A[:, None] + (x - x.min())*slope[:, None]).T
    
class StarryPhaseCurve(Mean):
    
    """The phase curve of a starry model. 
    A phase curve is generated by integrating the flux of a starry 
    map over the spherical body as it rotates. 
    
    Args:
        int lmax: the number of spherical harmonic orders
        tensor Y: the spherical harmonic coefficients
        float Prot: the rotation period of the body
    """
        
    def __init__(self, nw=1, **kwargs):
        validate_params(kwargs, self.get_param_names())
        super(StarryPhaseCurve, self).__init__(nw, **kwargs)
        
        self.starrymap = starry.Map(lmax=self.lmax, nwav=nw)
        try:
            for l in range(self.lmax):
                for m in range(2*l+1):
                    self.starrymap[l, m-l] = tt.ones(nw).fill(self.Y[l][m])
        except ValueError:
            print("Length of an entry in Y does not match the number of wavlengths, nw."
                 "All entries in Y should be either floats or arrays of length nw.")
        except IndexError:
            print("Invalid number of spherical harmonic coefficients.")
            
    def get_param_names(self):
        return ["lmax", "Y", "Prot"]
            
    def evaluate(self, x):
        theta = ((x % self.Prot) / self.Prot) * 360
        return self.starrymap.flux(theta=theta)
    
class StarryOccultationCurve(Mean):
    
    """The occultation light curve of a starry model. 
    A occultation light curve is generated by computing the 
    flux from a starry map as it is occulted by a body of radius r0. 
    
    Args:
        int lmax: the number of spherical harmonic orders
        tensor Y: the spherical harmonic coefficients
        float delta: the duration of the occultation
        float b0: the impact parameter of the occulting body
        float t0: the time at the center of the occultation
        float r0: the radius of the occulting body in 
            units of the radius of the occulted body
    """
        
    def __init__(self, nw=1, **kwargs):
        validate_params(kwargs, self.get_param_names())
        super(StarryOccultationCurve, self).__init__(nw, **kwargs)
        
        self.starrymaps = [starry.Map(lmax=self.lmax) for i in range(nw)]
        try:
            for l in range(self.lmax):
                for m in range(2*l+1):
                    for i in range(nw):
                        self.starrymaps[i][l, m-l] = self.Y[l][m][i]
        except ValueError:
            print("Length of an entry in Y does not match the number of wavlengths, nw."
                 "All entries in Y should be either floats or arrays of length nw.")
        except IndexError:
            print("Invalid number of spherical harmonic coefficients.")
            
    def get_param_names(self):
        return ["lmax", "Y", "delta", "b0", "t0", "r0"]
            
    def evaluate(self, x):
        
        v = 2 / self.delta
        xstart = - v * (self.t0 - x.min())
        x0 = xstart + v * x
        r0 = tt.ones(self.nw).fill(self.r0)
        return tt.stack([self.starrymaps[i].flux(xo=x0, yo=self.b0, ro=r0[i]) 
                for i in range(self.nw)]).T
    
class StarryLDCurve(Mean):
    
    """The occultation light curve of a starry model 
    with quadratic limb-darkening only. 
    
    Args:
        array u: the quadratic limb-darkening parameters
        float delta: the duration of the occultation
        float b0: the impact parameter of the occulting body
        float t0: the time at the center of the occultation
        float r0: the radius of the occulting body in units of the radius of the occulted body
    """
        
    def __init__(self, nw=1, **kwargs):
        validate_params(kwargs, self.get_param_names())
        super(StarryLDCurve, self).__init__(nw, **kwargs)
        
        self.starrymaps = [starry.Map(udeg=2) for i in range(nw)]
        
        try:
            for i in range(nw):
                self.starrymaps[i][1] = self.u[0][i]
                self.starrymaps[i][2] = self.u[1][i]
        except ValueError:
            print("Length of an entry in u does not match the number of wavlengths, nw."
                 "All entries in u should be either floats or arrays of length nw.")
            print(self.u)
            
    def get_param_names(self):
        return ["u", "delta", "b0", "t0", "r0"]
        
    def evaluate(self, x):
        
        v = 2 / self.delta
        xstart = - v * (self.t0 - x.min())
        x0 = xstart + v * x
        r0 = tt.ones(self.nw).fill(self.r0)
        return tt.stack([self.starrymaps[i].flux(xo=x0, yo=self.b0, ro=r0[i]) - 1 
                for i in range(self.nw)]).T